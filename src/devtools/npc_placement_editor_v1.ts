// Auto-generated by SweetLand NPC Placement Editor patch (v1)
// Purpose: let you cycle NPC IDs and record exact spawn poses, then copy JSON for hardcoding.
import * as THREE from "three";

type SavedPlacement = { id: string; name: string; x: number; y: number; z: number; yaw: number; t: number };

const G: any = globalThis as any;
const LS_KEY = "sweetland:npcPlacements:v1";
const HUD_ID = "npcPlacementEditorHudV1";

function safeParse<T>(s: string | null): T | null {
  if (!s) return null;
  try { return JSON.parse(s) as T; } catch { return null; }
}

function clamp(n: number, a: number, b: number) { return Math.max(a, Math.min(b, n)); }

function getNpcMetaList(): { id: string; name: string }[] {
  const raw = (Array.isArray(G.__sweetlandNpcList) ? G.__sweetlandNpcList : null)
    ?? (Array.isArray(G.__sweetlandNpcs) ? G.__sweetlandNpcs : null)
    ?? (Array.isArray(G.__sweetlandNpcMeta) ? G.__sweetlandNpcMeta : null);

  if (!Array.isArray(raw) || !raw.length) return [];

  const out: { id: string; name: string }[] = [];
  for (let i = 0; i < raw.length; i++) {
    const it: any = raw[i];
    if (typeof it === "string") {
      out.push({ id: it, name: it });
      continue;
    }
    const id = String(it.id ?? it.key ?? it.npcId ?? it.slug ?? it.name ?? it.displayName ?? `npc_${i}`);
    const name = String(it.displayName ?? it.label ?? it.name ?? id);
    out.push({ id, name });
  }
  // Dedup by id while preserving order
  const seen = new Set<string>();
  return out.filter(x => (seen.has(x.id) ? false : (seen.add(x.id), true)));
}

function getPlayerPose(): { x: number; y: number; z: number; yaw: number } | null {
  // Prefer a pose explicitly exposed by the game (we'll use it if present).
  const p = G.__sweetlandPlayerPose;
  if (p && typeof p.x === "number" && typeof p.z === "number") {
    return { x: p.x, y: p.y ?? 0, z: p.z, yaw: p.yaw ?? 0 };
  }

  const lvl: any = G.__sweetlandLevel;
  const candidate = lvl?.player ?? lvl?.playerRig ?? lvl?.character ?? lvl?.avatar ?? lvl?.playerObj ?? null;
  const cam = lvl?.camera ?? G.__sweetlandCamera ?? null;

  const obj: any = candidate ?? cam;
  if (obj?.position) {
    const x = Number(obj.position.x ?? 0);
    const y = Number(obj.position.y ?? 0);
    const z = Number(obj.position.z ?? 0);
    // yaw: try rotation, else derive from quaternion forward vector
    let yaw = 0;
    if (obj.rotation && typeof obj.rotation.y === "number") yaw = obj.rotation.y;
    else if (obj.quaternion) {
      const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(obj.quaternion);
      yaw = Math.atan2(fwd.x, fwd.z);
    }
    return { x, y, z, yaw };
  }

  return null;
}

function ensureHud(): HTMLDivElement {
  let hud = document.getElementById(HUD_ID) as HTMLDivElement | null;
  if (hud) return hud;

  hud = document.createElement("div");
  hud.id = HUD_ID;
  hud.style.position = "fixed";
  hud.style.left = "12px";
  hud.style.top = "12px";
  hud.style.zIndex = "99999";
  hud.style.padding = "10px 12px";
  hud.style.borderRadius = "10px";
  hud.style.background = "rgba(0,0,0,0.62)";
  hud.style.color = "#fff";
  hud.style.fontFamily = "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
  hud.style.fontSize = "12px";
  hud.style.whiteSpace = "pre";
  hud.style.pointerEvents = "none";
  hud.style.maxWidth = "46ch";
  hud.style.lineHeight = "1.25";
  document.body.appendChild(hud);
  return hud;
}

function toast(msg: string) {
  const tId = "npcPlacementEditorToastV1";
  let el = document.getElementById(tId) as HTMLDivElement | null;
  if (!el) {
    el = document.createElement("div");
    el.id = tId;
    el.style.position = "fixed";
    el.style.right = "12px";
    el.style.top = "12px";
    el.style.zIndex = "100000";
    el.style.padding = "10px 12px";
    el.style.borderRadius = "10px";
    el.style.background = "rgba(0,0,0,0.74)";
    el.style.color = "#fff";
    el.style.fontFamily = "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    el.style.fontSize = "12px";
    el.style.whiteSpace = "pre";
    el.style.pointerEvents = "none";
    document.body.appendChild(el);
  }
  el.textContent = msg;
  el.style.display = "block";
  clearTimeout((G.__npcPlacementEditorV1 as any)?.__toastT);
  (G.__npcPlacementEditorV1 as any).__toastT = window.setTimeout(() => { if (el) el.style.display = "none"; }, 900);
}

function getOrCreateMarkerGroup(scene: any): any {
  if (!scene) return null;
  let g = scene.getObjectByName?.("__npcPlacementMarkersV1");
  if (g) return g;
  g = new THREE.Group();
  g.name = "__npcPlacementMarkersV1";
  scene.add?.(g);
  return g;
}

function addMarker(scene: any, placement: SavedPlacement) {
  if (!scene) return;
  const group = getOrCreateMarkerGroup(scene);
  if (!group) return;

  // remove existing marker with same id
  const existing = group.children.find((c: any) => c.userData?.npcId === placement.id);
  if (existing) group.remove(existing);

  const marker = new THREE.Group();
  marker.userData.npcId = placement.id;
  marker.position.set(placement.x, placement.y, placement.z);
  marker.rotation.y = placement.yaw;

  const cone = new THREE.Mesh(
    new THREE.ConeGeometry(0.18, 0.5, 10),
    new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.85 })
  );
  cone.position.y = 0.25;
  marker.add(cone);

  const ring = new THREE.Mesh(
    new THREE.TorusGeometry(0.28, 0.035, 8, 18),
    new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.65 })
  );
  ring.rotation.x = Math.PI / 2;
  ring.position.y = 0.02;
  marker.add(ring);

  // Simple canvas label as a sprite (NOT raycasted; safe)
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 128;
  const ctx = canvas.getContext("2d")!;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "rgba(0,0,0,0.65)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#fff";
  ctx.font = "28px monospace";
  ctx.fillText(placement.name, 18, 54);
  ctx.font = "22px monospace";
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.fillText(placement.id, 18, 96);

  const tex = new THREE.CanvasTexture(canvas);
  tex.needsUpdate = true;
  const sprMat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0.95 });
  const spr = new THREE.Sprite(sprMat);
  spr.scale.set(3.8, 0.95, 1);
  spr.position.y = 1.4;
  marker.add(spr);

  group.add(marker);
}

async function copyToClipboard(text: string) {
  try {
    if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(text);
      return true;
    }
  } catch {}
  // fallback
  try {
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.style.position = "fixed";
    ta.style.left = "-10000px";
    ta.style.top = "0";
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    const ok = document.execCommand("copy");
    document.body.removeChild(ta);
    return ok;
  } catch {
    return false;
  }
}

function init() {
  if (G.__npcPlacementEditorV1) return;

  const saved = safeParse<Record<string, SavedPlacement>>(localStorage.getItem(LS_KEY)) ?? {};
  G.__npcPlacementEditorV1 = {
    active: false,
    idx: 0,
    saved,
  };

  const hud = ensureHud();

  const renderHud = () => {
    const st = G.__npcPlacementEditorV1 as { active: boolean; idx: number; saved: Record<string, SavedPlacement> };
    if (!st.active) {
      hud.style.display = "none";
      return;
    }

    const list = getNpcMetaList();
    st.idx = clamp(st.idx, 0, Math.max(0, list.length - 1));
    const sel = list[st.idx];

    const savedCount = Object.keys(st.saved).length;
    hud.textContent =
      `NPC Placement Editor (F7)\n` +
      `-------------------------\n` +
      `Selected: ${sel ? `${sel.name} (${sel.id}) [${st.idx + 1}/${list.length}]` : "(no NPC list)"}\n\n` +
      `[N] cycle NPC\n` +
      `[ENTER] save placement at YOUR feet + yaw\n` +
      `[C] copy placements JSON\n` +
      `[BACKSPACE] clear placements\n\n` +
      `Saved: ${savedCount}\n` +
      (savedCount ? `Tip: press C, paste JSON into chat.` : `Tip: walk where the NPC should stand, press ENTER.`);
  };

  const persist = () => {
    const st = G.__npcPlacementEditorV1 as { saved: Record<string, SavedPlacement> };
    localStorage.setItem(LS_KEY, JSON.stringify(st.saved));
  };

  const ensureMarkersFromSaved = () => {
    const lvl: any = G.__sweetlandLevel;
    const scene: any = lvl?.scene ?? lvl?.world?.scene ?? null;
    const st = G.__npcPlacementEditorV1 as { saved: Record<string, SavedPlacement> };
    if (!scene) return;
    for (const k of Object.keys(st.saved)) addMarker(scene, st.saved[k]);
  };

  document.addEventListener("keydown", async (e) => {
    const st = G.__npcPlacementEditorV1 as { active: boolean; idx: number; saved: Record<string, SavedPlacement> };
    if (!st) return;

    if (e.code === "F7") {
      st.active = !st.active;
      e.preventDefault();
      e.stopPropagation();
      if (st.active) {
        toast("NPC Placement Editor: ON\nN cycle • ENTER save • C copy");
        ensureMarkersFromSaved();
      } else {
        toast("NPC Placement Editor: OFF");
      }
      renderHud();
      return;
    }

    if (!st.active) return;

    // In editor mode, prevent the game from also acting on these keys.
    if (e.code === "KeyN" || e.code === "Enter" || e.code === "Backspace" || e.code === "KeyC") {
      e.preventDefault();
      e.stopPropagation();
    }

    const list = getNpcMetaList();

    if (e.code === "KeyN") {
      if (!list.length) {
        toast("No NPC list available.\nMake sure the level exposed __sweetlandNpcList.");
        renderHud();
        return;
      }
      st.idx = (st.idx + 1) % list.length;
      const sel = list[st.idx];
      toast(`Selected:\n${sel.name}\n(${sel.id})  [${st.idx + 1}/${list.length}]`);
      renderHud();
      return;
    }

    if (e.code === "Enter") {
      if (!list.length) { toast("No NPC list available."); return; }
      const sel = list[st.idx];
      const pose = getPlayerPose();
      if (!pose) {
        toast("Couldn't read player pose.\n(Need __sweetlandPlayerPose or __sweetlandLevel.player/camera)");
        renderHud();
        return;
      }
      const rec: SavedPlacement = { id: sel.id, name: sel.name, x: pose.x, y: pose.y, z: pose.z, yaw: pose.yaw, t: Date.now() };
      st.saved[sel.id] = rec;
      persist();

      const lvl: any = G.__sweetlandLevel;
      const scene: any = lvl?.scene ?? lvl?.world?.scene ?? null;
      addMarker(scene, rec);

      toast(`Saved placement:\n${sel.name}\n${pose.x.toFixed(2)}, ${pose.y.toFixed(2)}, ${pose.z.toFixed(2)}  yaw ${pose.yaw.toFixed(2)}`);
      renderHud();
      return;
    }

    if (e.code === "KeyC") {
      const arr = Object.values(st.saved).sort((a, b) => a.id.localeCompare(b.id));
      const json = JSON.stringify(arr, null, 2);
      const ok = await copyToClipboard(json);
      toast(ok ? `Copied JSON (${arr.length} NPCs).` : "Copy failed. Open DevTools > Console and run copy(JSON.stringify(...))");
      // Also log for safety
      console.info("[SweetLand] NPC placements JSON:", arr);
      renderHud();
      return;
    }

    if (e.code === "Backspace") {
      st.saved = {};
      G.__npcPlacementEditorV1.saved = st.saved;
      persist();
      const lvl: any = G.__sweetlandLevel;
      const scene: any = lvl?.scene ?? lvl?.world?.scene ?? null;
      const grp = scene?.getObjectByName?.("__npcPlacementMarkersV1");
      if (grp) scene.remove(grp);
      toast("Cleared saved placements.");
      renderHud();
      return;
    }
  }, true);

  // Render once on init
  renderHud();
}

init();
