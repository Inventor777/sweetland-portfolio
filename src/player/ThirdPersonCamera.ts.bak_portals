import * as THREE from "three";
import { clamp } from "../core/clamp";

export class ThirdPersonCamera {
  // Yaw/pitch controlled by mouse (pointer lock)
  yaw = 0;
  pitch = -0.15; // angled down

  // SWEETLAND_CAMERA_COLLISION_V3: prevent walls/terrain from blocking the player (camera push-in)
  private occluders: THREE.Object3D[] = [];
  private ray = new THREE.Raycaster();
  private focusY = 1.0;     // focus point above player (meters)
  private padding = 0.25;   // how far in front of wall to keep camera (meters)
  private _focus = new THREE.Vector3();
  private _dir = new THREE.Vector3();
  private _tmp = new THREE.Vector3();

  setOccluders(objs: THREE.Object3D[]): void {
    this.occluders = Array.isArray(objs) ? objs : [];
  }
  // A bit farther out for better platforming visibility
  distance = 8.2;
  height = 3.0;

  // Smoothed camera position
  private camPos = new THREE.Vector3();
  private targetPos = new THREE.Vector3();

  constructor(private camera: THREE.PerspectiveCamera) {}

  updateFromMouse(dx: number, dy: number): void {
    const sens = 0.0024;
    this.yaw -= dx * sens;
    this.pitch -= dy * sens;
    this.pitch = clamp(this.pitch, -0.15, -0.15); // SWEETLAND_LOCK_PITCH_V6 // SWEETLAND_LOCK_PITCH_V6 // SWEETLAND_LOCK_PITCH_V6 // SWEETLAND_LOCK_PITCH_V6 // SWEETLAND_LOCK_PITCH_V6
  }

  update(targetWorldPos: THREE.Vector3, dt: number): void {
    // Camera target is slightly above player
    this.targetPos.copy(targetWorldPos).add(new THREE.Vector3(0, 1.2, 0));

    // Spherical offsets
    const x = Math.sin(this.yaw) * Math.cos(this.pitch) * this.distance;
    const y = Math.sin(this.pitch) * this.distance + this.height;
    const z = Math.cos(this.yaw) * Math.cos(this.pitch) * this.distance;

    const desired = this.targetPos.clone().add(new THREE.Vector3(x, y, z));

    // Smooth follow (critically damp-ish)
    const k = 1 - Math.pow(0.001, dt);
    this.camPos.lerp(desired, k);

    this.camera.position.copy(this.camPos);

    // SWEETLAND_CAMERA_COLLISION_V3: raycast from player -> desired camera. If blocked, slide camera forward.
    if (this.occluders && this.occluders.length) {
      this._focus.copy(this.targetPos);
      this._focus.y += this.focusY;

      this._dir.subVectors(this.camera.position, this._focus);
      const dist = this._dir.length();

      if (dist > 0.001) {
        this._dir.multiplyScalar(1.0 / dist);
        this.ray.set(this._focus, this._dir);
        this.ray.far = dist;

        const hits = this.ray.intersectObjects(this.occluders, true);
        if (hits && hits.length) {
          // Pull camera in front of the first blocker
          this._tmp.copy(hits[0].point).addScaledVector(this._dir, -this.padding);

          // Don't let camera get *too* close to the player
          const minDist = 0.65;
          if (this._tmp.distanceTo(this._focus) < minDist) {
            this._tmp.copy(this._focus).addScaledVector(this._dir, minDist);
          }

          const a = clamp(dt * 12, 0, 1);
          this.camera.position.lerp(this._tmp, a);
        }
      }
    }

    this.camera.lookAt(this.targetPos);
  }
}
